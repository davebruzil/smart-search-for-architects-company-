<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×××’×¨ ×—×‘×¨×•×ª ×œ××“×¨×™×›×œ×™× - ×—×™×¤×•×© ×—×›×</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .ai-badge {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin: 10px 0;
            display: inline-block;
        }
        
        .ai-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .ai-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .ai-toggle.active {
            background: #8e2de2;
            color: white;
            border-color: #8e2de2;
        }
        
        .ai-thinking {
            background: linear-gradient(45deg, #8e2de2, #4a00e0);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            display: none;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .ai-explanation {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 10px 10px 0;
            font-size: 0.95rem;
            display: none;
        }
        
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .search-section {
            padding: 40px;
            background: #f8f9fa;
        }
        
        .search-container {
            position: relative;
            margin-bottom: 30px;
        }
        
        .search-input {
            width: 100%;
            padding: 20px;
            font-size: 1.2rem;
            border: 3px solid #e9ecef;
            border-radius: 15px;
            outline: none;
            transition: all 0.3s ease;
            text-align: right;
            direction: rtl;
        }
        
        .search-input:focus {
            border-color: #8e2de2;
            box-shadow: 0 0 0 5px rgba(142, 45, 226, 0.1);
        }
        
        .search-button {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .search-button:hover {
            transform: translateY(-50%) translateY(-2px);
            box-shadow: 0 5px 15px rgba(142, 45, 226, 0.3);
        }
        
        .search-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: translateY(-50%);
            box-shadow: none;
        }
        
        .mic-button {
            position: absolute;
            left: 130px;
            top: 50%;
            transform: translateY(-50%);
            background: #e74c3c;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .mic-button:hover {
            background: #c0392b;
            transform: translateY(-50%) scale(1.1);
        }
        
        .mic-button.recording {
            background: #27ae60;
            animation: pulse-mic 1.5s infinite;
        }
        
        .mic-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: translateY(-50%);
        }
        
        @keyframes pulse-mic {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
            }
            50% { 
                box-shadow: 0 0 0 10px rgba(231, 76, 60, 0);
            }
        }
        
        .speech-status {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-top: none;
            border-radius: 0 0 15px 15px;
            padding: 10px;
            text-align: center;
            font-size: 0.9rem;
            color: #6c757d;
            display: none;
        }
        
        .filters {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .filter-select {
            padding: 10px 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            outline: none;
        }
        
        .results-section {
            padding: 0 40px 40px;
        }
        
        .system-mode-indicator {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .mode-badge {
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .reset-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .reset-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
        
        .filter-system {
            display: block;
        }
        
        .speech-system {
            border: 2px solid #e74c3c;
            border-radius: 15px;
            padding: 20px;
            background: #fdf2f2;
            position: relative;
        }
        
        .speech-system::before {
            content: "ğŸ¤ ××¦×‘ ×—×™×¤×•×© ×§×•×œ×™";
            position: absolute;
            top: -12px;
            right: 20px;
            background: #e74c3c;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }
        
        .results-count {
            font-size: 1.2rem;
            color: #2c3e50;
            font-weight: 600;
        }
        
        .sort-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .company-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .company-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        
        
        .company-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 15px;
        }
        
        .company-name {
            font-size: 1.4rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .company-type {
            background: #3498db;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        
        .company-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .detail-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .detail-icon {
            width: 20px;
            height: 20px;
            fill: #3498db;
        }
        
        .contact-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .contact-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .email-btn {
            background: #e74c3c;
            color: white;
        }
        
        .phone-btn {
            background: #27ae60;
            color: white;
        }
        
        .website-btn {
            background: #f39c12;
            color: white;
        }
        
        .contact-btn:hover {
            transform: scale(1.05);
        }
        
        .no-results {
            text-align: center;
            padding: 60px;
            color: #7f8c8d;
            font-size: 1.2rem;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.1rem;
            color: #3498db;
        }
        
        .search-suggestions {
            background: white;
            border: 1px solid #e9ecef;
            border-top: none;
            border-radius: 0 0 15px 15px;
            max-height: 200px;
            overflow-y: auto;
            position: absolute;
            width: 100%;
            z-index: 1000;
            display: none;
        }
        
        .suggestion-item {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
            transition: background 0.2s ease;
        }
        
        .suggestion-item:hover {
            background: #f8f9fa;
        }
        
        .highlight {
            background: yellow;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>×××’×¨ ×—×‘×¨×•×ª ×œ××“×¨×™×›×œ×™×</h1>
            <p>××¢×¨×›×ª ×—×™×¤×•×© ×—×‘×¨×•×ª ×‘×™×©×¨××œ ×œ××“×¨×™×›×œ×™× ×¢×¦×××™×™×</p>
        </div>
        
        <div class="search-section">
                
            
            <div class="search-container">
                <input type="text" 
                       class="search-input" 
                       id="searchInput" 
                       placeholder="×—×¤×© ×—×‘×¨×•×ª... (×œ×“×•×’××”: ×‘×ª×™ ×¡×¤×¨, ×¢×™×¨×™×•×ª, ×‘×ª×™ ×—×•×œ×™×)">
                <button class="search-button" onclick="performSearch()" id="searchBtn">ğŸ” ×—×¤×©</button>
                <button class="mic-button" onclick="toggleSpeechRecognition()" id="micBtn" title="×—×™×¤×•×© ×§×•×œ×™">ğŸ¤</button>
                <div class="search-suggestions" id="suggestions"></div>
                <div class="speech-status" id="speechStatus"></div>
            </div>
            
            
            <div class="filters">
                <select class="filter-select" id="regionFilter">
                    <option value="">×›×œ ×”××–×•×¨×™×</option>
                </select>
                <select class="filter-select" id="typeFilter">
                    <option value="">×›×œ ×¡×•×’×™ ×”×—×‘×¨×•×ª</option>
                </select>
            </div>
        </div>
        
        <div class="results-section">
            <!-- SYSTEM MODE INDICATOR -->
            <div class="system-mode-indicator" id="systemModeIndicator" style="display: none;">
                <div class="mode-badge" id="modeBadge"></div>
                <button class="reset-btn" id="resetBtn" onclick="resetToFilterMode()">ğŸ”„ ×—×–×•×¨ ×œ×—×™×¤×•×© ×¨×’×™×œ</button>
            </div>
            
            <!-- FILTER SYSTEM CONTAINER -->
            <div class="filter-system" id="filterSystem">
                <div class="results-header" id="filterResultsHeader" style="display: none;">
                    <div class="results-count" id="filterResultsCount"></div>
                    <div class="sort-controls">
                        <label>××™×•×Ÿ ×œ×¤×™:</label>
                        <select class="filter-select" id="sortBy">
                            <option value="relevance">×¨×œ×•×•× ×˜×™×•×ª</option>
                            <option value="name">×©× ×”×—×‘×¨×”</option>
                            <option value="type">×¡×•×’ ×”×—×‘×¨×”</option>
                            <option value="region">××–×•×¨</option>
                        </select>
                    </div>
                </div>
                <div id="filterResults"></div>
            </div>
            
            <!-- SPEECH SYSTEM CONTAINER -->
            <div class="speech-system" id="speechSystem" style="display: none;">
                <div class="results-header" id="speechResultsHeader" style="display: none;">
                    <div class="results-count" id="speechResultsCount"></div>
                    <div class="sort-controls">
                        <label>××™×•×Ÿ ×œ×¤×™:</label>
                        <select class="filter-select" id="speechSortBy">
                            <option value="relevance">×¨×œ×•×•× ×˜×™×•×ª</option>
                            <option value="name">×©× ×”×—×‘×¨×”</option>
                            <option value="type">×¡×•×’ ×”×—×‘×¨×”</option>
                            <option value="region">××–×•×¨</option>
                        </select>
                    </div>
                </div>
                <div id="speechResults"></div>
            </div>
            
            <!-- LEGACY CONTAINER (HIDDEN) -->
            <div id="results" style="display: none;"></div>
        </div>
    </div>

    <!-- Load configuration -->
    <script src="config.js"></script>
    <script>
        // ========== SHARED DATA (READ-ONLY) ==========
        let companiesData = null;
        let regionsData = null;
        let companyTypesData = null;
        let apiKey = null;
        let enrichedCompanies = []; // Store RAG-enhanced companies
        let isRAGInitialized = false;
        
        // ========== FILTER SYSTEM STATE (ISOLATED) ==========
        const FilterSystem = {
            results: [],
            currentSearchMode: 'smart',
            lastQuery: '',
            isActive: true
        };
        
        // ========== SPEECH SYSTEM STATE (ISOLATED) ==========
        const SpeechSystem = {
            results: [],
            lastQuery: '',
            isActive: false,
            mediaRecorder: null,
            isRecording: false,
            audioChunks: []
        };
        
        // ========== SYSTEM MODE MANAGEMENT ==========
        let currentSystemMode = 'filter'; // 'filter' or 'speech'
        
        function switchToSpeechMode(query) {
            console.log('ğŸ¤ Switching to Speech Mode');
            currentSystemMode = 'speech';
            SpeechSystem.isActive = true;
            FilterSystem.isActive = false;
            
            // Hide filter system, show speech system
            document.getElementById('filterSystem').style.display = 'none';
            document.getElementById('speechSystem').style.display = 'block';
            
            // Show mode indicator
            const indicator = document.getElementById('systemModeIndicator');
            const badge = document.getElementById('modeBadge');
            indicator.style.display = 'flex';
            badge.textContent = `ğŸ¤ ××¦×‘ ×—×™×¤×•×© ×§×•×œ×™: "${query}"`;
            
            console.log('âœ… Speech mode activated');
        }
        
        function switchToFilterMode() {
            console.log('ğŸ” Switching to Filter Mode');
            currentSystemMode = 'filter';
            FilterSystem.isActive = true;
            SpeechSystem.isActive = false;
            
            // Show filter system, hide speech system
            document.getElementById('filterSystem').style.display = 'block';
            document.getElementById('speechSystem').style.display = 'none';
            
            // Hide mode indicator
            document.getElementById('systemModeIndicator').style.display = 'none';
            
            console.log('âœ… Filter mode activated');
        }
        
        function resetToFilterMode() {
            console.log('ğŸ”„ Resetting to Filter Mode');
            
            // Clear speech system
            SpeechSystem.results = [];
            SpeechSystem.lastQuery = '';
            document.getElementById('speechResults').innerHTML = '';
            document.getElementById('speechResultsHeader').style.display = 'none';
            
            // Switch to filter mode
            switchToFilterMode();
            
            // Re-apply current filters
            applyFilters();
        }
        
        // Load data when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ğŸš€ DOM loaded, initializing app...');
            await loadData();
            console.log('ğŸ“Š Data loaded, setting up listeners...');
            setupEventListeners();
            console.log('ğŸ›ï¸ Setting up filters...');
            populateFilters();
            console.log('âœ… App fully initialized!');
            // Load API key from config
            apiKey = window.CONFIG?.OPENAI_API_KEY || null;
            if (apiKey) {
                console.log('ğŸ”‘ OpenAI API key loaded from config');
            } else {
                console.log('âš ï¸ No OpenAI API key found. AI features will be disabled.');
            }
        });
        
        async function loadData() {
            try {
                const response = await fetch('./map-clean.json');
                const data = await response.json();
                
                companiesData = data.companies || [];
                regionsData = data.regions || [];
                companyTypesData = data.companyTypes || [];
                
                // Check if companies have RAG enhancements
                const isRAGEnhanced = companiesData.length > 0 && companiesData[0].hasOwnProperty('embedding');
                console.log(`Loaded ${companiesData.length} companies (RAG Enhanced: ${isRAGEnhanced}), ${regionsData.length} regions, ${companyTypesData.length} types`);
                
                // Update UI to show enhanced capabilities
                if (isRAGEnhanced) {
                    document.querySelector('h1').innerHTML = '×××’×¨ ×—×‘×¨×•×ª ××ª×§×“× ×œ××“×¨×™×›×œ×™×';
                }
                
            } catch (error) {
                console.error('Error loading enhanced data, falling back to basic data:', error);
                // Fallback to basic data
                try {
                    const response = await fetch('./map-public.json');
                    const text = await response.text();
                    const cleanedText = text.replace(/,(\s*[}\]])/g, '$1');
                    const data = eval('(' + cleanedText + ')');
                    
                    companiesData = data.companies || [];
                    regionsData = data.regions || [];
                    companyTypesData = data.companyTypes || [];
                    
                    console.log(`Loaded ${companiesData.length} companies (Basic mode), ${regionsData.length} regions, ${companyTypesData.length} types`);
                } catch (fallbackError) {
                    console.error('Error loading data:', fallbackError);
                    document.getElementById('results').innerHTML = '<div class="no-results">×©×’×™××” ×‘×˜×¢×™× ×ª ×”× ×ª×•× ×™×</div>';
                }
            }
        }
        
        function populateFilters() {
            console.log('ğŸ“‹ Populating filters...');
            const regionFilter = document.getElementById('regionFilter');
            const typeFilter = document.getElementById('typeFilter');
            
            console.log('ğŸŒ Regions:', regionsData.length);
            console.log('ğŸ¢ Types:', companyTypesData.length);
            
            // Populate regions
            regionsData.forEach(region => {
                const option = document.createElement('option');
                option.value = region.id;
                option.textContent = region.shortName;
                regionFilter.appendChild(option);
            });
            
            // Populate company types
            companyTypesData.forEach(type => {
                const option = document.createElement('option');
                option.value = type.id;
                option.textContent = type.typeName;
                typeFilter.appendChild(option);
            });
            
            console.log('âœ… Filters populated - Regions:', regionFilter.options.length - 1, 'Types:', typeFilter.options.length - 1);
        }
        
        function setupEventListeners() {
            console.log('ğŸ§ Setting up event listeners...');
            const searchInput = document.getElementById('searchInput');
            
            searchInput.addEventListener('input', debounce(showSuggestions, 300));
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    performSearch();
                }
            });
            
            // Filter change listeners - ONLY work in filter mode
            document.getElementById('regionFilter').addEventListener('change', () => {
                if (FilterSystem.isActive) {
                    applyFilters();
                }
            });
            document.getElementById('typeFilter').addEventListener('change', () => {
                if (FilterSystem.isActive) {
                    applyFilters();
                }
            });
            document.getElementById('sortBy').addEventListener('change', () => {
                if (FilterSystem.isActive) {
                    sortFilterResults();
                }
            });
            
            // Speech system sort listener
            document.getElementById('speechSortBy').addEventListener('change', () => {
                if (SpeechSystem.isActive) {
                    sortSpeechResults();
                }
            });
            
            console.log('âœ… All event listeners attached with isolation');
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function showSuggestions() {
            const query = document.getElementById('searchInput').value.trim();
            const suggestionsDiv = document.getElementById('suggestions');
            
            if (query.length < 2) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            const suggestions = generateSuggestions(query);
            
            if (suggestions.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            suggestionsDiv.innerHTML = suggestions
                .slice(0, 5)
                .map(suggestion => `<div class="suggestion-item" onclick="selectSuggestion('${suggestion}')">${suggestion}</div>`)
                .join('');
            
            suggestionsDiv.style.display = 'block';
        }
        
        function generateSuggestions(query) {
            const suggestions = new Set();
            const queryLower = query.toLowerCase();
            
            // Company name suggestions
            companiesData.forEach(company => {
                if (company.companyName && company.companyName.toLowerCase().includes(queryLower)) {
                    suggestions.add(company.companyName);
                }
            });
            
            // Company type suggestions
            companyTypesData.forEach(type => {
                if (type.typeName.toLowerCase().includes(queryLower)) {
                    suggestions.add(type.typeName);
                }
            });
            
            // Region suggestions
            regionsData.forEach(region => {
                if (region.shortName.toLowerCase().includes(queryLower) || 
                    region.title.toLowerCase().includes(queryLower)) {
                    suggestions.add(region.shortName);
                }
            });
            
            return Array.from(suggestions);
        }
        
        function selectSuggestion(suggestion) {
            document.getElementById('searchInput').value = suggestion;
            document.getElementById('suggestions').style.display = 'none';
            performSearch();
        }
        
        
        function toggleSearchMode(mode) {
            currentSearchMode = mode;
            
            // Update UI
            document.querySelectorAll('.ai-toggle').forEach(el => el.classList.remove('active'));
            document.getElementById(mode + 'Mode').classList.add('active');
            
            // Update search placeholder
            const searchInput = document.getElementById('searchInput');
            const placeholders = {
                'smart': '×ª××¨ ××” ××ª×” ××—×¤×© ×‘×©×¤×” ×˜×‘×¢×™×ª...',
                'semantic': '×—×¤×© ×œ×¤×™ ××©××¢×•×ª ×•×œ× ×¨×§ ××™×œ×™× ××“×•×™×§×•×ª...'
            };
            searchInput.placeholder = placeholders[mode];
        }
        
        function applyFilters() {
            // ONLY works if filter system is active
            if (!FilterSystem.isActive) {
                console.log('âš ï¸ Filter system inactive, ignoring filter call');
                return;
            }
            
            console.log('ğŸ” Applying filters (Filter System)');
            
            const query = document.getElementById('searchInput').value.trim();
            const regionId = document.getElementById('regionFilter').value;
            const typeId = document.getElementById('typeFilter').value;
            
            // Store query in filter system
            FilterSystem.lastQuery = query;
            
            // If nothing is selected, don't show anything
            if (!query && !regionId && !typeId) {
                document.getElementById('filterResults').innerHTML = '';
                document.getElementById('filterResultsHeader').style.display = 'none';
                FilterSystem.results = [];
                return;
            }
            
            // Start with all companies
            let results = [...companiesData];
            
            // Apply region filter
            if (regionId) {
                results = results.filter(company => company.regionId == regionId);
            }
            
            // Apply type filter  
            if (typeId) {
                results = results.filter(company => company.typeId == typeId);
            }
            
            // Apply search query
            if (query) {
                const queryLower = query.toLowerCase();
                results = results.filter(company => {
                    const searchText = [
                        company.companyName || '',
                        company.companyType || '',
                        company.region || '',
                        company.comment || ''
                    ].join(' ').toLowerCase();
                    
                    return searchText.includes(queryLower);
                });
            }
            
            // Add search score
            results = results.map(company => ({ ...company, searchScore: 1 }));
            
            // Store in filter system and display
            FilterSystem.results = results;
            displayFilterResults(results);
        }
        
        async function performSearch() {
            const query = document.getElementById('searchInput').value.trim();
            
            // If no query, just apply filters
            if (!query) {
                applyFilters();
                return;
            }
            
            // If API key available, use AI-enhanced search
            if (apiKey) {
                await performAIEnhancedSearch(query);
            } else {
                applyFilters();
            }
        }
        
        async function performAIEnhancedSearch(query) {
            const searchBtn = document.getElementById('searchBtn');
            
            try {
                searchBtn.disabled = true;
                searchBtn.textContent = '×× ×ª×—...';
                
                // Get AI analysis of the query
                const aiAnalysis = await analyzeQueryWithAI(query);
                
                // Apply enhanced filtering with AI insights
                applyAIEnhancedFilters(query, aiAnalysis);
                
            } catch (error) {
                console.error('AI search failed, using basic search:', error);
                applyFilters();
            } finally {
                searchBtn.disabled = false;
                searchBtn.textContent = 'ğŸ” ×—×¤×©';
            }
        }
        
        async function analyzeQueryWithAI(query) {
            const prompt = `You are helping search through a database of Israeli companies for freelance architects.

Available company types: ${companyTypesData.map(t => t.typeName).join(', ')}
Available regions: ${regionsData.map(r => r.shortName).join(', ')}

User query in Hebrew: "${query}"

Analyze this query and extract:
1. What type of companies they're looking for
2. Which region they might be interested in (×¦×¤×•×Ÿ=North, ××¨×›×–=Center, ×“×¨×•×=South, ×™×¨×•×©×œ×™×=Jerusalem)  
3. Additional search terms that would help find relevant companies
4. The intent behind their search

Return ONLY valid JSON:
{
  "companyTypes": ["list of relevant company type names from the available types"],
  "preferredRegion": "region name if mentioned, or null",
  "searchTerms": ["expanded", "search", "terms", "including", "synonyms"],
  "intent": "brief description of what they're looking for",
  "expandedQuery": "enhanced search query with related terms"
}`;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 500
                })
            });
            
            const data = await response.json();
            
            try {
                return JSON.parse(data.choices[0].message.content);
            } catch (parseError) {
                // Fallback if JSON parsing fails
                return {
                    companyTypes: [],
                    preferredRegion: null,
                    searchTerms: [query],
                    intent: "×—×™×¤×•×© ×‘×¡×™×¡×™",
                    expandedQuery: query
                };
            }
        }
        
        function applyAIEnhancedFilters(originalQuery, aiAnalysis) {
            const regionId = document.getElementById('regionFilter').value;
            const typeId = document.getElementById('typeFilter').value;
            
            // Start with all companies
            let results = [...companiesData];
            
            // Apply manual filters first (user selections override AI)
            if (regionId) {
                results = results.filter(company => company.regionId == regionId);
            } else if (aiAnalysis.preferredRegion) {
                // Apply AI-detected region if no manual selection
                const matchedRegion = regionsData.find(region => 
                    region.shortName.includes(aiAnalysis.preferredRegion) ||
                    aiAnalysis.preferredRegion.includes(region.shortName)
                );
                if (matchedRegion) {
                    results = results.filter(company => company.regionId == matchedRegion.id);
                }
            }
            
            if (typeId) {
                results = results.filter(company => company.typeId == typeId);
            } else if (aiAnalysis.companyTypes.length > 0) {
                // Apply AI-detected company types if no manual selection
                const matchedTypeIds = companyTypesData
                    .filter(type => aiAnalysis.companyTypes.some(aiType => 
                        type.typeName.includes(aiType) || aiType.includes(type.typeName)
                    ))
                    .map(type => type.id);
                
                if (matchedTypeIds.length > 0) {
                    results = results.filter(company => matchedTypeIds.includes(company.typeId));
                }
            }
            
            // Enhanced text search with AI insights
            const allSearchTerms = [
                originalQuery,
                ...aiAnalysis.searchTerms,
                aiAnalysis.expandedQuery
            ].filter(term => term && term.length > 0);
            
            if (allSearchTerms.length > 0) {
                results = results.filter(company => {
                    const searchText = [
                        company.companyName || '',
                        company.companyType || '',
                        company.region || '',
                        company.comment || ''
                    ].join(' ').toLowerCase();
                    
                    // Check if any of the AI-enhanced search terms match
                    return allSearchTerms.some(term => 
                        searchText.includes(term.toLowerCase())
                    );
                });
            }
            
            // Add search score based on relevance
            results = results.map(company => {
                let score = 1;
                
                // Boost score for AI-detected company types
                if (aiAnalysis.companyTypes.some(aiType => 
                    (company.companyType || '').includes(aiType)
                )) {
                    score += 2;
                }
                
                // Boost score for exact query matches
                const searchText = [
                    company.companyName || '',
                    company.companyType || '',
                    company.comment || ''
                ].join(' ').toLowerCase();
                
                if (searchText.includes(originalQuery.toLowerCase())) {
                    score += 3;
                }
                
                return { ...company, searchScore: score };
            });
            
            // Sort by relevance
            results.sort((a, b) => b.searchScore - a.searchScore);
            
            // Display results with AI context
            displayAIResults(results, aiAnalysis);
        }
        
        function displayAIResults(results, aiAnalysis) {
            const resultsDiv = document.getElementById('results');
            const resultsHeader = document.getElementById('resultsHeader');
            const resultsCount = document.getElementById('resultsCount');
            
            if (results.length === 0) {
                resultsDiv.innerHTML = '<div class="no-results">×œ× × ××¦××• ×ª×•×¦××•×ª ××ª××™××•×ª.</div>';
                resultsHeader.style.display = 'none';
                return;
            }
            
            let countText = `× ××¦××• ${results.length} ×—×‘×¨×•×ª`;
            if (aiAnalysis && aiAnalysis.intent) {
                countText += ` - ${aiAnalysis.intent}`;
            }
            
            resultsCount.textContent = countText;
            resultsHeader.style.display = 'flex';
            
            resultsDiv.innerHTML = results.map(company => createCompanyCard(company)).join('');
            currentResults = results;
        }
        
        function performAISearch() {
            performSearch();
        }
        
        // MODE SWITCHING SYSTEM
        function switchToSpeechMode(query) {
            currentSystemMode = 'speech';
            SpeechSystem.isActive = true;
            FilterSystem.isActive = false;
            
            // Hide filter system, show speech system  
            document.getElementById('filterSystem').style.display = 'none';
            document.getElementById('speechSystem').style.display = 'block';
            
            // Show mode indicator
            document.getElementById('systemModeIndicator').style.display = 'flex';
            document.getElementById('modeBadge').textContent = `ğŸ¤ ××¦×‘ ×—×™×¤×•×© ×§×•×œ×™: "${query}"`;
        }
        
        function switchToFilterMode() {
            currentSystemMode = 'filter';
            FilterSystem.isActive = true;
            SpeechSystem.isActive = false;
            
            // Show filter system, hide speech system
            document.getElementById('filterSystem').style.display = 'block';
            document.getElementById('speechSystem').style.display = 'none';
            
            // Hide mode indicator
            document.getElementById('systemModeIndicator').style.display = 'none';
        }
        
        function resetToFilterMode() {
            console.log('ğŸ”„ Resetting to Filter Mode');
            
            // Clear speech system completely
            SpeechSystem.results = [];
            SpeechSystem.lastQuery = '';
            SpeechSystem.isActive = false;
            
            // Clear speech results
            document.getElementById('speechResults').innerHTML = '';
            document.getElementById('speechResultsHeader').style.display = 'none';
            
            // Reset current system mode
            currentSystemMode = 'filter';
            FilterSystem.isActive = true;
            
            // Show filter system, hide speech system
            document.getElementById('filterSystem').style.display = 'block';
            document.getElementById('speechSystem').style.display = 'none';
            
            // Hide mode indicator
            document.getElementById('systemModeIndicator').style.display = 'none';
            
            // Clear search input to reset state
            document.getElementById('searchInput').value = '';
            
            // Clear any existing filter results
            document.getElementById('filterResults').innerHTML = '';
            document.getElementById('filterResultsHeader').style.display = 'none';
            FilterSystem.results = [];
            FilterSystem.lastQuery = '';
            
            // Reset filter dropdowns to default
            document.getElementById('regionFilter').value = '';
            document.getElementById('typeFilter').value = '';
            
            console.log('âœ… Filter mode restored and reset');
        }
        
        async function performSpeechSearch(query) {
            if (!query) return;
            
            console.log('ğŸ¤ Starting Enhanced AI Speech Search');
            
            // Switch to speech mode
            switchToSpeechMode(query);
            
            const searchBtn = document.getElementById('searchBtn');
            
            try {
                searchBtn.disabled = true;
                searchBtn.textContent = '×× ×ª×— ×‘×××¦×¢×•×ª AI...';
                
                console.log('ğŸ¤ Enhanced speech search started:', query);
                console.log('ğŸ“Š Total companies available:', companiesData?.length);
                
                let results = [...companiesData];
                
                if (!results || results.length === 0) {
                    console.error('âŒ No company data available!');
                    displaySpeechResults([], query);
                    return;
                }
                
                // PHASE 1: AI Analysis of Speech Query
                let aiAnalysis = null;
                if (apiKey) {
                    try {
                        searchBtn.textContent = 'ğŸ¤– ×× ×ª×— ×›×•×•× ×”...';
                        aiAnalysis = await analyzeQueryWithAI(query);
                        console.log('ğŸ§  AI Analysis:', aiAnalysis);
                    } catch (error) {
                        console.log('âš ï¸ AI analysis failed, using fallback logic');
                    }
                }
                
                // PHASE 2: Apply Intelligent Filtering
                searchBtn.textContent = 'ğŸ” ××¡× ×Ÿ ×ª×•×¦××•×ª...';
                
                // Apply AI-detected regional filtering
                if (aiAnalysis && aiAnalysis.preferredRegion) {
                    const regionName = aiAnalysis.preferredRegion;
                    console.log('ğŸŒ AI detected region:', regionName);
                    
                    const matchedRegion = regionsData.find(region => 
                        region.shortName.includes(regionName) || 
                        regionName.includes(region.shortName) ||
                        (regionName.includes('×¦×¤×•×Ÿ') && region.shortName === '×¦×¤×•×Ÿ') ||
                        (regionName.includes('××¨×›×–') && region.shortName === '××¨×›×–') ||
                        (regionName.includes('×“×¨×•×') && region.shortName === '×“×¨×•×') ||
                        (regionName.includes('×™×¨×•×©×œ×™×') && region.shortName === '×™×¨×•×©×œ×™×')
                    );
                    
                    if (matchedRegion) {
                        results = results.filter(company => company.regionId == matchedRegion.id);
                        console.log(`ğŸ¯ Filtered by region ${regionName}: ${results.length} companies`);
                    }
                } else {
                    // Fallback: Manual region detection
                    const queryLower = query.toLowerCase();
                    if (queryLower.includes('×¦×¤×•×Ÿ') || queryLower.includes('north')) {
                        results = results.filter(company => company.regionId == 1);
                        console.log('ğŸ¯ Manual region detection - North:', results.length);
                    } else if (queryLower.includes('××¨×›×–') || queryLower.includes('center')) {
                        results = results.filter(company => company.regionId == 2);
                        console.log('ğŸ¯ Manual region detection - Center:', results.length);
                    } else if (queryLower.includes('×“×¨×•×') || queryLower.includes('south')) {
                        results = results.filter(company => company.regionId == 3);
                        console.log('ğŸ¯ Manual region detection - South:', results.length);
                    } else if (queryLower.includes('×™×¨×•×©×œ×™×') || queryLower.includes('jerusalem')) {
                        results = results.filter(company => company.regionId == 4);
                        console.log('ğŸ¯ Manual region detection - Jerusalem:', results.length);
                    }
                }
                
                // Apply AI-detected company type filtering
                if (aiAnalysis && aiAnalysis.companyTypes && aiAnalysis.companyTypes.length > 0) {
                    console.log('ğŸ¢ AI detected company types:', aiAnalysis.companyTypes);
                    
                    const matchedTypeIds = companyTypesData
                        .filter(type => aiAnalysis.companyTypes.some(aiType => 
                            type.typeName.includes(aiType) || aiType.includes(type.typeName)
                        ))
                        .map(type => type.id);
                    
                    if (matchedTypeIds.length > 0) {
                        results = results.filter(company => matchedTypeIds.includes(company.typeId));
                        console.log(`ğŸ¯ Filtered by AI company types: ${results.length} companies`);
                    }
                } else {
                    // Enhanced fallback: Intelligent Hebrew type mapping
                    const queryLower = query.toLowerCase();
                    const intelligentMappings = {
                        '×‘×ª×™ ×—×•×œ×™×': [4, 5], // Hospitals and health institutions
                        '×—×•×œ×™×': [4, 5],
                        '×¨×¤×•××”': [4, 5],
                        '×‘×¨×™××•×ª': [4, 5],
                        '×‘×ª×™ ×¡×¤×¨': [6, 7], // Educational institutions
                        '×—×™× ×•×š': [6, 7],
                        '×‘×™×”"×¡': [6, 7],
                        '××•× ×™×‘×¨×¡×™×˜': [6, 7],
                        '×¢×™×¨×™×•×ª': [5], // Municipalities
                        '×¢×™×¨×™×™×”': [5],
                        '××•×¢×¦×”': [4], // Regional councils
                        '×××©×œ×”': [1], // Government offices
                        '××©×¨×“': [1, 2], // Government offices and companies
                        '×ª×¨×‘×•×ª': [8, 9] // Cultural institutions
                    };
                    
                    for (const [term, typeIds] of Object.entries(intelligentMappings)) {
                        if (queryLower.includes(term)) {
                            const beforeFilter = results.length;
                            results = results.filter(company => typeIds.includes(company.typeId));
                            console.log(`ğŸ¯ Manual type detection - ${term}: ${beforeFilter} â†’ ${results.length} companies`);
                            break; // Use first match
                        }
                    }
                }
                
                // PHASE 3: Semantic Search and Scoring
                searchBtn.textContent = 'ğŸ§  ××—×©×‘ ×¨×œ×•×•× ×˜×™×•×ª...';
                results = await searchAndScore(results, query, aiAnalysis);
                
                // Take top results for speech (more focused)
                results = results.slice(0, 50);
                
                console.log('ğŸ“‹ Final enhanced speech search results:', results.length);
                
                // Store in speech system and display
                SpeechSystem.results = results;
                SpeechSystem.lastQuery = query;
                displaySpeechResults(results, query);
                
            } catch (error) {
                console.error('âŒ Enhanced speech search failed:', error);
                SpeechSystem.results = [];
                displaySpeechResults([], query);
            } finally {
                searchBtn.disabled = false;
                searchBtn.textContent = 'ğŸ” ×—×¤×©';
            }
        }
        
        function displayFilterResults(results) {
            console.log('ğŸ” Displaying filter results:', results.length);
            
            const resultsDiv = document.getElementById('filterResults');
            const resultsHeader = document.getElementById('filterResultsHeader');
            const resultsCount = document.getElementById('filterResultsCount');
            
            if (results.length === 0) {
                resultsDiv.innerHTML = '<div class="no-results">×œ× × ××¦××• ×ª×•×¦××•×ª ××ª××™××•×ª. × ×¡×” ×—×™×¤×•×© ××—×¨ ××• ×©× ×” ××ª ×”×¤×™×œ×˜×¨×™×.</div>';
                resultsHeader.style.display = 'none';
                return;
            }
            
            resultsCount.textContent = `× ××¦××• ${results.length} ×—×‘×¨×•×ª`;
            resultsHeader.style.display = 'flex';
            
            resultsDiv.innerHTML = results.map(company => createCompanyCard(company)).join('');
            
            console.log('âœ… Filter results displayed successfully');
        }
        
        function displaySpeechResults(results, query) {
            console.log('ğŸ¤ Displaying speech results:', results.length);
            
            // Switch to speech mode and activate speech system
            switchToSpeechMode(query);
            
            const resultsDiv = document.getElementById('speechResults');
            const resultsHeader = document.getElementById('speechResultsHeader');
            const resultsCount = document.getElementById('speechResultsCount');
            
            // Store in speech system state
            SpeechSystem.results = results;
            SpeechSystem.lastQuery = query;
            
            if (results.length === 0) {
                resultsDiv.innerHTML = '<div class="no-results">×œ× × ××¦××• ×ª×•×¦××•×ª ×œ×—×™×¤×•×© ×”×§×•×œ×™.</div>';
                resultsHeader.style.display = 'none';
                return;
            }
            
            resultsCount.textContent = `× ××¦××• ${results.length} ×—×‘×¨×•×ª`;
            resultsHeader.style.display = 'flex';
            
            resultsDiv.innerHTML = results.map(company => createCompanyCard(company)).join('');
            
            console.log('âœ… Speech results displayed successfully in isolated container');
        }
        
        function sortFilterResults() {
            const sortBy = document.getElementById('sortBy').value;
            
            if (!FilterSystem.results.length || !FilterSystem.isActive) return;
            
            console.log('ğŸ” Sorting filter results by:', sortBy);
            
            switch (sortBy) {
                case 'name':
                    FilterSystem.results.sort((a, b) => (a.companyName || '').localeCompare(b.companyName || '', 'he'));
                    break;
                case 'type':
                    FilterSystem.results.sort((a, b) => (a.companyType || '').localeCompare(b.companyType || '', 'he'));
                    break;
                case 'region':
                    FilterSystem.results.sort((a, b) => (a.region || '').localeCompare(b.region || '', 'he'));
                    break;
                case 'relevance':
                default:
                    FilterSystem.results.sort((a, b) => (b.searchScore || 0) - (a.searchScore || 0));
                    break;
            }
            
            displayFilterResults(FilterSystem.results);
        }
        
        function sortSpeechResults() {
            const sortBy = document.getElementById('speechSortBy').value;
            
            if (!SpeechSystem.results.length || !SpeechSystem.isActive) return;
            
            console.log('ğŸ¤ Sorting speech results by:', sortBy);
            
            switch (sortBy) {
                case 'name':
                    SpeechSystem.results.sort((a, b) => (a.companyName || '').localeCompare(b.companyName || '', 'he'));
                    break;
                case 'type':
                    SpeechSystem.results.sort((a, b) => (a.companyType || '').localeCompare(b.companyType || '', 'he'));
                    break;
                case 'region':
                    SpeechSystem.results.sort((a, b) => (a.region || '').localeCompare(b.region || '', 'he'));
                    break;
                case 'relevance':
                default:
                    SpeechSystem.results.sort((a, b) => (b.searchScore || 0) - (a.searchScore || 0));
                    break;
            }
            
            displaySpeechResults(SpeechSystem.results, SpeechSystem.lastQuery);
        }
        
        
        
        
        async function performOpenAISearch(query) {
            const searchContext = `You are helping search through a database of Israeli companies for freelance architects.

Available company types: ${companyTypesData.map(t => t.typeName).join(', ')}
Available regions: ${regionsData.map(r => r.shortName).join(', ')}

User query: "${query}"

Analyze the query for:
1. Regional intent (×¦×¤×•×Ÿ=North, ××¨×›×–=Center, ×“×¨×•×=South, ×™×¨×•×©×œ×™×=Jerusalem)
2. Company type preferences 
3. Architectural specialties mentioned
4. Project types implied

Provide a comprehensive analysis in Hebrew and suggest relevant filters and search terms.

IMPORTANT: Return ONLY valid JSON in this exact format:
{
  "explanation": "×”×¡×‘×¨ ××¤×•×¨×˜ ×‘×¢×‘×¨×™×ª ×¢×œ ××” ×”××©×ª××© ××—×¤×©",
  "relevantTypes": ["exact company type names from the list above"],
  "searchTerms": ["additional", "search", "terms", "including", "regional", "terms"],
  "regionIntent": "region name if mentioned or null",
  "typeIntent": "company type if mentioned or null"
}`;
            
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: [{ role: 'user', content: searchContext }],
                    temperature: 0.3
                })
            });
            
            const data = await response.json();
            console.log('OpenAI raw response:', data.choices[0].message.content);
            
            let aiResponse = null;
            try {
                // Try to parse JSON response
                const content = data.choices[0].message.content.trim();
                aiResponse = JSON.parse(content);
            } catch (jsonError) {
                console.log('JSON parse failed, using fallback');
                // If JSON parsing fails, create a basic response
                aiResponse = {
                    explanation: "AI ×× ×ª×— ××ª ×”×©××™×œ×ª×”",
                    relevantTypes: [],
                    searchTerms: query.split(' ').filter(word => word.length > 2)
                };
            }
            
            // AI explanation removed for cleaner UI
            
            // Add English to Hebrew translation for common terms
            const enhancedContext = {
                ...aiResponse,
                searchTerms: [...(aiResponse.searchTerms || []), ...translateCommonTerms(query)]
            };
            
            return performIntelligentSearch(query, enhancedContext);
        }
        
        function translateCommonTerms(query) {
            const translations = {
                'school': '×‘×™×ª ×¡×¤×¨',
                'hospital': '×‘×™×ª ×—×•×œ×™×', 
                'municipality': '×¢×™×¨×™×™×”',
                'culture': '×ª×¨×‘×•×ª',
                'north': '×¦×¤×•×Ÿ',
                'south': '×“×¨×•×',
                'center': '××¨×›×–',
                'jerusalem': '×™×¨×•×©×œ×™×'
            };
            
            const terms = [];
            Object.keys(translations).forEach(eng => {
                if (query.toLowerCase().includes(eng)) {
                    terms.push(translations[eng]);
                }
            });
            
            return terms;
        }
        
        async function performSemanticSearch(query) {
            
            // Enhanced semantic mapping
            const semanticMaps = {
                '×‘×ª×™ ×¡×¤×¨': ['×—×™× ×•×š', '×œ×™××•×“×™×', '×ª×œ××™×“×™×', '×‘×™×”"×¡', '××•×¡×“×•×ª ×—×™× ×•×š', '××§×“××™×”'],
                '×‘×ª×™ ×—×•×œ×™×': ['×¨×¤×•××”', '×‘×¨×™××•×ª', '×§×•×¤×ª ×—×•×œ×™×', '××¨×¤××”', '××¨×›×– ×¨×¤×•××™'],
                '×ª×¨×‘×•×ª': ['××•×–×™××•×Ÿ', '×ª×™××˜×¨×•×Ÿ', '××¨×›×– ×§×”×™×œ×ª×™', '××× ×•×ª', '××•×¤×¢×™×', '×¡×¤×¨×™×™×”'],
                '×ª×©×ª×™×ª': ['×›×‘×™×©×™×', '×ª×—×‘×•×¨×”', '××™×', '×‘×™×•×‘', '×—×©××œ', '×’×©×¨×™×', '×× ×”×¨×•×ª'],
                '××’×•×¨×™×': ['×“×™×•×¨', '×©×›×•× ×•×ª', '×‘×™× ×•×™', '×“×™×¨×•×ª', '×‘×ª×™× ×¤×¨×˜×™×™×'],
                '×¡×¤×•×¨×˜': ['××ª×§× ×™ ×¡×¤×•×¨×˜', '××¦×˜×“×™×•×Ÿ', '×‘×¨×™×›×”', '×›×•×©×¨', '×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª']
            };
            
            let expandedQuery = query;
            Object.keys(semanticMaps).forEach(key => {
                if (query.includes(key)) {
                    expandedQuery += ' ' + semanticMaps[key].join(' ');
                }
            });
            
            return performIntelligentSearch(expandedQuery);
        }
        
        async function performIntelligentSearch(query, aiContext = null) {
            let results = [...companiesData];
            console.log('ğŸš€ Starting intelligent search with', results.length, 'companies');
            
            // Apply manual filter selections first
            const regionFilter = document.getElementById('regionFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            console.log('ğŸ›ï¸ Manual filters - Region:', regionFilter, 'Type:', typeFilter);
            
            if (regionFilter) {
                results = results.filter(company => company.regionId == parseInt(regionFilter));
                console.log('ğŸŒ After region filter:', results.length, 'companies');
            }
            
            if (typeFilter) {
                results = results.filter(company => company.typeId == parseInt(typeFilter));
                console.log('ğŸ¢ After type filter:', results.length, 'companies');
            }
            
            // Apply AI-detected regional intent (if no manual filter is set)
            if (!regionFilter && aiContext && aiContext.regionIntent) {
                const regionName = aiContext.regionIntent;
                const matchedRegion = regionsData.find(region => 
                    region.shortName.includes(regionName) || 
                    regionName.includes(region.shortName) ||
                    (regionName === '×¦×¤×•×Ÿ' && region.shortName === '×¦×¤×•×Ÿ') ||
                    (regionName === '××¨×›×–' && region.shortName === '××¨×›×–') ||
                    (regionName === '×“×¨×•×' && region.shortName === '×“×¨×•×') ||
                    (regionName === '×™×¨×•×©×œ×™×' && region.shortName === '×™×¨×•×©×œ×™×')
                );
                
                if (matchedRegion) {
                    results = results.filter(company => company.regionId == matchedRegion.id);
                    console.log(`ğŸ¯ AI detected region: ${regionName}, filtered to ${results.length} companies`);
                }
            }
            
            // Apply AI-detected type intent (if no manual filter is set)  
            if (!typeFilter && aiContext && aiContext.typeIntent) {
                const typeName = aiContext.typeIntent;
                const matchedType = companyTypesData.find(type => 
                    type.typeName.includes(typeName) || typeName.includes(type.typeName)
                );
                
                if (matchedType) {
                    results = results.filter(company => company.typeId == matchedType.id);
                    console.log(`ğŸ¯ AI detected type: ${typeName}, filtered to ${results.length} companies`);
                }
            }
            
            // Apply AI context filters for company types (broader search)
            if (aiContext && aiContext.relevantTypes && aiContext.relevantTypes.length > 0) {
                const relevantTypeIds = companyTypesData
                    .filter(type => aiContext.relevantTypes.some(rt => 
                        type.typeName.includes(rt) || rt.includes(type.typeName)
                    ))
                    .map(type => type.id);
                
                console.log('ğŸ¤– AI suggested types:', aiContext.relevantTypes);
                console.log('ğŸ“‹ Matched type IDs:', relevantTypeIds);
                
                // Only apply if we haven't already filtered by type
                if (!typeFilter && !aiContext.typeIntent && relevantTypeIds.length > 0) {
                    const filteredResults = results.filter(company => relevantTypeIds.includes(company.typeId));
                    if (filteredResults.length > 0) {
                        results = filteredResults;
                        console.log(`ğŸ¯ Applied AI type filter: ${results.length} companies`);
                    }
                }
            }
            
            return await searchAndScore(results, query, aiContext);
        }
        
        function performSearch() {
            // Keep the old method as fallback
            applyFilters();
        }
        
        // RAG Vector Search Helper Functions
        function cosineSimilarity(vecA, vecB) {
            if (!vecA || !vecB || vecA.length !== vecB.length) return 0;
            
            const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
            const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
            const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
            
            if (magnitudeA === 0 || magnitudeB === 0) return 0;
            return dotProduct / (magnitudeA * magnitudeB);
        }
        
        async function generateQueryEmbedding(query) {
            if (!apiKey) return null;
            
            try {
                const response = await fetch('https://api.openai.com/v1/embeddings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'text-embedding-3-small',
                        input: query
                    })
                });
                
                const data = await response.json();
                return data.data[0].embedding;
            } catch (error) {
                console.error('Error generating query embedding:', error);
                return null;
            }
        }

        async function searchAndScore(companies, query, aiContext = null) {
            const queryLower = query.toLowerCase();
            const queryWords = queryLower.split(/\s+/);
            
            // Check if companies have embeddings (RAG enhanced)
            const hasEmbeddings = companies.length > 0 && companies[0].hasOwnProperty('embedding');
            let queryEmbedding = null;
            
            // Generate query embedding if we have RAG data
            if (hasEmbeddings && apiKey) {
                queryEmbedding = await generateQueryEmbedding(query);
                if (queryEmbedding) {
                    console.log('ğŸ§  RAG Vector Search activated');
                }
            }
            
            return companies
                .map(company => {
                    let score = 0;
                    
                    // RAG Vector Similarity (highest priority if available)
                    if (queryEmbedding && company.embedding) {
                        const similarity = cosineSimilarity(queryEmbedding, company.embedding);
                        if (similarity > 0.3) { // Relevance threshold
                            score += similarity * 1000; // High weight for vector similarity
                        }
                    }
                    
                    // Traditional search scoring as backup/enhancement
                    const searchableText = [
                        company.companyName || '',
                        company.companyType || '',
                        company.region || '',
                        company.comment || '',
                        company.aiDescription || '', // Include RAG-generated description
                        (company.projectTypes || []).join(' '),
                        (company.architectSpecialties || []).join(' ')
                    ].join(' ').toLowerCase();
                    
                    // Exact phrase match
                    if (searchableText.includes(queryLower)) {
                        score += 100;
                    }
                    
                    // Individual word matches
                    queryWords.forEach(word => {
                        if (word.length > 1) {
                            if (searchableText.includes(word)) {
                                score += 10;
                            }
                            
                            // Company name gets extra weight
                            if ((company.companyName || '').toLowerCase().includes(word)) {
                                score += 20;
                            }
                            
                            // Company type gets medium weight
                            if ((company.companyType || '').toLowerCase().includes(word)) {
                                score += 15;
                            }
                            
                            // RAG enhanced fields get high weight
                            if ((company.aiDescription || '').toLowerCase().includes(word)) {
                                score += 30;
                            }
                        }
                    });
                    
                    // Smart matching for common architecture terms
                    const architectureTerms = {
                        '×‘×™×ª ×¡×¤×¨': ['×‘×™×ª ×¡×¤×¨', '×—×™× ×•×š', '×‘×™×”"×¡'],
                        '×‘×™×ª ×—×•×œ×™×': ['×‘×™×ª ×—×•×œ×™×', '×¨×¤×•××”', '×‘×¨×™××•×ª', '×§×•×¤×ª ×—×•×œ×™×'],
                        '×¢×™×¨×™×™×”': ['×¢×™×¨×™×™×”', '×¢×™×¨×™×•×ª', '××•×¢×¦×”'],
                        '××“×¨×™×›×œ': ['××“×¨×™×›×œ', '×ª×›× ×•×Ÿ', '×‘× ×™×™×”'],
                        '×ª×©×ª×™×ª': ['×ª×©×ª×™×ª', '×›×‘×™×©×™×', '×ª×—×‘×•×¨×”', '××™×'],
                        '××’×•×¨×™×': ['××’×•×¨×™×', '×“×™×•×¨', '×©×›×•× ×•×ª'],
                        '×ª×¨×‘×•×ª': ['×ª×¨×‘×•×ª', '××•×–×™××•×Ÿ', '×ª×™××˜×¨×•×Ÿ', '××¨×›×– ×§×”×™×œ×ª×™']
                    };
                    
                    Object.keys(architectureTerms).forEach(term => {
                        if (queryLower.includes(term)) {
                            architectureTerms[term].forEach(relatedTerm => {
                                if (searchableText.includes(relatedTerm)) {
                                    score += 25;
                                }
                            });
                        }
                    });
                    
                    // AI Context Bonus
                    if (aiContext && aiContext.searchTerms) {
                        aiContext.searchTerms.forEach(term => {
                            if (searchableText.includes(term.toLowerCase())) {
                                score += 30;
                            }
                        });
                    }
                    
                    return { 
                        ...company, 
                        searchScore: score,
                        ragEnhanced: queryEmbedding && company.embedding ? true : false
                    };
                })
                .filter(company => company.searchScore > 0)
                .sort((a, b) => b.searchScore - a.searchScore);
        }
        
        
        // Legacy function - replaced by displayFilterResults
        function displayResults(results) {
            console.log('âš ï¸ displayResults is deprecated - routing to displayFilterResults');
            displayFilterResults(results);
        }
        
        function createAICompanyCard(company) {
            const hasPhone = company.tel && company.tel.trim();
            const hasWebsite = company.site && company.site.trim() && !company.site.includes('mailto:');
            const hasEmail = company.site && company.site.includes('mailto:');
            
            return `
                <div class="company-card">
                    
                    <div class="company-header">
                        <div>
                            <div class="company-name">${company.companyName || '×©× ×œ× ×–××™×Ÿ'}</div>
                            <div style="color: #7f8c8d; font-size: 0.9rem;">${company.region || '××–×•×¨ ×œ× ×–××™×Ÿ'}</div>
                        </div>
                        <div class="company-type">${company.companyType || '×¡×•×’ ×œ× ×–××™×Ÿ'}</div>
                    </div>
                    
                    <div class="company-details">
                        <div class="detail-item">
                            <svg class="detail-icon" viewBox="0 0 20 20">
                                <path d="M10 2L3 7v11h4v-6h6v6h4V7l-7-5z"/>
                            </svg>
                            <span>${company.region || '××–×•×¨ ×œ× ×–××™×Ÿ'}</span>
                        </div>
                        <div class="detail-item">
                            <svg class="detail-icon" viewBox="0 0 20 20">
                                <path d="M7 3v14l5-5 5 5V3H7z"/>
                            </svg>
                            <span>${company.companyType || '×¡×•×’ ×œ× ×–××™×Ÿ'}</span>
                        </div>
                    </div>
                    
                    ${company.aiDescription ? `<div style="background: #e8f4fd; padding: 12px; border-radius: 8px; margin: 15px 0; font-size: 0.95rem; color: #2c3e50; border-left: 3px solid #3498db;">${company.aiDescription}</div>` : ''}
                    
                    ${company.comment ? `<div style="background: #f8f9fa; padding: 10px; border-radius: 8px; margin: 10px 0; font-size: 0.9rem; color: #6c757d;">${company.comment}</div>` : ''}
                    
                    <div class="contact-actions">
                        ${hasPhone ? `<button class="contact-btn phone-btn" onclick="callCompany('${company.tel}')" title="×”×ª×§×©×¨">ğŸ“ ${company.tel}</button>` : ''}
                        ${hasEmail ? `<button class="contact-btn email-btn" onclick="emailCompany('${company.site}')" title="×©×œ×— ×“×•××¨ ××œ×§×˜×¨×•× ×™">âœ‰ï¸ ×“×•××¨</button>` : ''}
                        ${hasWebsite ? `<button class="contact-btn website-btn" onclick="visitWebsite('${company.site}')" title="×‘×§×¨ ×‘××ª×¨">ğŸŒ ××ª×¨</button>` : ''}
                    </div>
                </div>
            `;
        }
        
        function sortResults() {
            console.log('âš ï¸ sortResults is deprecated - use sortFilterResults instead');
            sortFilterResults();
        }
        
        // Duplicate function removed - using displayFilterResults
        
        function createCompanyCard(company) {
            const hasPhone = company.tel && company.tel.trim();
            const hasWebsite = company.site && company.site.trim() && !company.site.includes('mailto:');
            const hasEmail = company.site && company.site.includes('mailto:');
            
            return `
                <div class="company-card">
                    <div class="company-header">
                        <div>
                            <div class="company-name">${company.companyName || '×©× ×œ× ×–××™×Ÿ'}</div>
                            <div style="color: #7f8c8d; font-size: 0.9rem;">${company.region || '××–×•×¨ ×œ× ×–××™×Ÿ'}</div>
                        </div>
                        <div class="company-type">${company.companyType || '×¡×•×’ ×œ× ×–××™×Ÿ'}</div>
                    </div>
                    
                    <div class="company-details">
                        <div class="detail-item">
                            <svg class="detail-icon" viewBox="0 0 20 20">
                                <path d="M10 2L3 7v11h4v-6h6v6h4V7l-7-5z"/>
                            </svg>
                            <span>${company.region || '××–×•×¨ ×œ× ×–××™×Ÿ'}</span>
                        </div>
                        <div class="detail-item">
                            <svg class="detail-icon" viewBox="0 0 20 20">
                                <path d="M7 3v14l5-5 5 5V3H7z"/>
                            </svg>
                            <span>${company.companyType || '×¡×•×’ ×œ× ×–××™×Ÿ'}</span>
                        </div>
                    </div>
                    
                    ${company.comment ? `<div style="background: #f8f9fa; padding: 10px; border-radius: 8px; margin: 10px 0; font-size: 0.9rem; color: #6c757d;">${company.comment}</div>` : ''}
                    
                    <div class="contact-actions">
                        ${hasPhone ? `<button class="contact-btn phone-btn" onclick="callCompany('${company.tel}')" title="×”×ª×§×©×¨">ğŸ“ ${company.tel}</button>` : ''}
                        ${hasEmail ? `<button class="contact-btn email-btn" onclick="emailCompany('${company.site}')" title="×©×œ×— ×“×•××¨ ××œ×§×˜×¨×•× ×™">âœ‰ï¸ ×“×•××¨</button>` : ''}
                        ${hasWebsite ? `<button class="contact-btn website-btn" onclick="visitWebsite('${company.site}')" title="×‘×§×¨ ×‘××ª×¨">ğŸŒ ××ª×¨</button>` : ''}
                    </div>
                </div>
            `;
        }
        
        function callCompany(phone) {
            window.open(`tel:${phone}`, '_blank');
        }
        
        function emailCompany(emailLink) {
            window.open(emailLink, '_blank');
        }
        
        function visitWebsite(website) {
            if (!website.startsWith('http://') && !website.startsWith('https://')) {
                website = 'https://' + website;
            }
            window.open(website, '_blank');
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                document.getElementById('suggestions').style.display = 'none';
            }
        });
        
        // Speech-to-Text Functions
        async function toggleSpeechRecognition() {
            if (!apiKey) {
                alert('× ×“×¨×© ××¤×ª×— OpenAI API ×¢×‘×•×¨ ×—×™×¤×•×© ×§×•×œ×™');
                return;
            }
            
            if (SpeechSystem.isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }
        
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                SpeechSystem.mediaRecorder = new MediaRecorder(stream);
                SpeechSystem.audioChunks = [];
                SpeechSystem.isRecording = true;
                
                const micBtn = document.getElementById('micBtn');
                const speechStatus = document.getElementById('speechStatus');
                
                micBtn.classList.add('recording');
                micBtn.innerHTML = 'ğŸ”´';
                micBtn.title = '×¢×¦×•×¨ ×”×§×œ×˜×”';
                
                speechStatus.innerHTML = 'ğŸ¤ ××§×œ×™×˜... ×œ×—×¥ ×©×•×‘ ×›×“×™ ×œ×¢×¦×•×¨';
                speechStatus.style.display = 'block';
                
                SpeechSystem.mediaRecorder.ondataavailable = (event) => {
                    SpeechSystem.audioChunks.push(event.data);
                };
                
                SpeechSystem.mediaRecorder.onstop = () => {
                    processAudio();
                };
                
                SpeechSystem.mediaRecorder.start();
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                alert('×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××™×§×¨×•×¤×•×Ÿ. × × ×œ×•×•×“× ×©×”×¨×©×ª ×’×™×©×”.');
            }
        }
        
        function stopRecording() {
            if (SpeechSystem.mediaRecorder && SpeechSystem.isRecording) {
                SpeechSystem.mediaRecorder.stop();
                SpeechSystem.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                SpeechSystem.isRecording = false;
                
                const micBtn = document.getElementById('micBtn');
                const speechStatus = document.getElementById('speechStatus');
                
                micBtn.classList.remove('recording');
                micBtn.innerHTML = 'ğŸ¤';
                micBtn.title = '×—×™×¤×•×© ×§×•×œ×™';
                
                speechStatus.innerHTML = 'ğŸ¤– ××¢×‘×“ ××ª ×”×”×§×œ×˜×”...';
            }
        }
        
        async function processAudio() {
            const speechStatus = document.getElementById('speechStatus');
            
            try {
                const audioBlob = new Blob(SpeechSystem.audioChunks, { type: 'audio/wav' });
                
                // Create FormData for OpenAI Whisper API
                const formData = new FormData();
                formData.append('file', audioBlob, 'recording.wav');
                formData.append('model', 'whisper-1');
                formData.append('language', 'he'); // Hebrew language
                
                speechStatus.innerHTML = 'ğŸ¤– OpenAI ××ª×¨×’× ××ª ×”×“×™×‘×•×¨ ×œ×˜×§×¡×˜...';
                
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const transcription = data.text;
                
                if (transcription && transcription.trim()) {
                    // Set the transcription in search input
                    document.getElementById('searchInput').value = transcription;
                    
                    // Auto-search after speech recognition - IGNORE ALL FILTERS
                    speechStatus.innerHTML = `âœ… ×–×•×”×”: "${transcription}"`;
                    
                    setTimeout(() => {
                        performSpeechSearch(transcription);
                        speechStatus.style.display = 'none';
                    }, 1000);
                    
                } else {
                    speechStatus.innerHTML = 'âŒ ×œ× ×–×•×”×” ×“×™×‘×•×¨. × ×¡×” ×©×•×‘.';
                    setTimeout(() => {
                        speechStatus.style.display = 'none';
                    }, 3000);
                }
                
            } catch (error) {
                console.error('Error transcribing audio:', error);
                speechStatus.innerHTML = 'âŒ ×©×’×™××” ×‘×ª×¨×’×•× ×”×“×™×‘×•×¨. × ×¡×” ×©×•×‘.';
                setTimeout(() => {
                    speechStatus.style.display = 'none';
                }, 3000);
            }
        }
    </script>
</body>
</html>